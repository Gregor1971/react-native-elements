{"version":3,"sources":["../../src/slider/Slider.js"],"names":["TRACK_SIZE","THUMB_SIZE","DEFAULT_ANIMATION_CONFIGS","spring","friction","tension","timing","duration","easing","inOut","ease","delay","Rect","x","y","width","height","prototype","containsPoint","Slider","props","state","containerSize","trackSize","thumbSize","allMeasured","value","Value","panResponder","create","onStartShouldSetPanResponder","handleStartShouldSetPanResponder","bind","onMoveShouldSetPanResponder","handleMoveShouldSetPanResponder","onPanResponderGrant","handlePanResponderGrant","onPanResponderMove","handlePanResponderMove","onPanResponderRelease","handlePanResponderEnd","onPanResponderTerminationRequest","handlePanResponderRequestEnd","onPanResponderTerminate","nextProps","newValue","animateTransitions","setCurrentValueAnimated","setCurrentValue","setValue","animationType","animationConfig","toValue","start","_previousLeft","getThumbLeft","getCurrentValue","fireChangeEvent","e","gestureState","disabled","getValue","nativeEvent","thumbTouchRect","getThumbTouchRect","locationX","locationY","thumbHitTest","event","size","Math","max","thumbTouchSize","getTouchOverflowSize","touchOverflowStyle","undefined","verticalMargin","marginTop","marginBottom","horizontalMargin","marginLeft","marginRight","debugTouchArea","backgroundColor","opacity","name","layout","storeName","currentSize","_containerSize","_trackSize","_thumbSize","setState","handleMeasure","length","thumbLeft","orientation","dy","dx","ratio","step","minimumValue","min","maximumValue","round","__getValue","getRatio","touchOverflowSize","positionStyle","left","top","minimumTrackTintColor","maximumTrackTintColor","thumbTintColor","containerStyle","style","trackStyle","thumbStyle","onSlidingStart","onSlidingComplete","other","process","env","NODE_ENV","onValueChange","mainStyles","styles","interpolate","inputRange","outputRange","valueVisibleStyle","minimumTrackStyle","position","add","thumbStyleTransform","transform","getTouchOverflowStyle","container","rotate","measureContainer","track","measureTrack","measureThumb","thumb","translateX","translateY","touchArea","panHandlers","renderDebugThumbTouchRect","propTypes","number","bool","string","shape","func","oneOf","object","defaultProps","justifyContent","borderRadius","right","bottom","debugThumbTouchArea"],"mappings":"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","file":"Slider.js","sourcesContent":["import PropTypes from 'prop-types';\nimport React, { Component } from 'react';\nimport { View, StyleSheet, Animated, Easing, PanResponder } from 'react-native';\nimport ViewPropTypes from '../config/ViewPropTypes';\n\n// import shallowCompare from 'react-addons-shallow-compare';\n// import styleEqual from 'style-equal'\n\nconst TRACK_SIZE = 4;\nconst THUMB_SIZE = 20;\n\nvar DEFAULT_ANIMATION_CONFIGS = {\n  spring: {\n    friction: 7,\n    tension: 100,\n  },\n  timing: {\n    duration: 150,\n    easing: Easing.inOut(Easing.ease),\n    delay: 0,\n  },\n};\n\nfunction Rect(x, y, width, height) {\n  this.x = x;\n  this.y = y;\n  this.width = width;\n  this.height = height;\n}\n\nRect.prototype.containsPoint = function(x, y) {\n  return (\n    x >= this.x &&\n    y >= this.y &&\n    x <= this.x + this.width &&\n    y <= this.y + this.height\n  );\n};\n\nexport default class Slider extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      containerSize: { width: 0, height: 0 },\n      trackSize: { width: 0, height: 0 },\n      thumbSize: { width: 0, height: 0 },\n      allMeasured: false,\n      value: new Animated.Value(props.value),\n    };\n  }\n\n  componentWillMount() {\n    this.panResponder = PanResponder.create({\n      onStartShouldSetPanResponder: this.handleStartShouldSetPanResponder.bind(\n        this\n      ),\n      onMoveShouldSetPanResponder: this.handleMoveShouldSetPanResponder.bind(\n        this\n      ),\n      onPanResponderGrant: this.handlePanResponderGrant.bind(this),\n      onPanResponderMove: this.handlePanResponderMove.bind(this),\n      onPanResponderRelease: this.handlePanResponderEnd.bind(this),\n      onPanResponderTerminationRequest: this.handlePanResponderRequestEnd.bind(\n        this\n      ),\n      onPanResponderTerminate: this.handlePanResponderEnd.bind(this),\n    });\n  }\n\n  componentWillReceiveProps(nextProps) {\n    var newValue = nextProps.value;\n\n    if (this.props.value !== newValue) {\n      if (this.props.animateTransitions) {\n        this.setCurrentValueAnimated(newValue);\n      } else {\n        this.setCurrentValue(newValue);\n      }\n    }\n  }\n\n  // shouldComponentUpdate(nextProps, nextState) {\n  //   // We don't want to re-render in the following cases:\n  //   // - when only the 'value' prop changes as it's already handled with the Animated.Value\n  //   // - when the event handlers change (rendering doesn't depend on them)\n  //   // - when the style props haven't actually change\n  //\n  //   return shallowCompare(\n  //     { props: this._getPropsForComponentUpdate(this.props), state: this.state },\n  //     this._getPropsForComponentUpdate(nextProps),\n  //     nextState\n  //   ) || !styleEqual(this.props.style, nextProps.style)\n  //     || !styleEqual(this.props.trackStyle, nextProps.trackStyle)\n  //     || !styleEqual(this.props.thumbStyle, nextProps.thumbStyle);\n  // }\n  //\n  // _getPropsForComponentUpdate(props) {\n  //   var {\n  //     value,\n  //     onValueChange,\n  //     onSlidingStart,\n  //     onSlidingComplete,\n  //     style,\n  //     trackStyle,\n  //     thumbStyle,\n  //     ...otherProps,\n  //   } = props;\n  //\n  //   return otherProps;\n  // }\n\n  setCurrentValue(value) {\n    this.state.value.setValue(value);\n  }\n\n  setCurrentValueAnimated(value) {\n    var animationType = this.props.animationType;\n    var animationConfig = Object.assign(\n      {},\n      DEFAULT_ANIMATION_CONFIGS[animationType],\n      this.props.animationConfig,\n      {\n        toValue: value,\n      }\n    );\n\n    Animated[animationType](this.state.value, animationConfig).start();\n  }\n\n  handleMoveShouldSetPanResponder(/*e: Object, gestureState: Object*/) {\n    // Should we become active when the user moves a touch over the thumb?\n    return false;\n  }\n\n  handlePanResponderGrant(/*e: Object, gestureState: Object*/) {\n    this._previousLeft = this.getThumbLeft(this.getCurrentValue());\n    this.fireChangeEvent('onSlidingStart');\n  }\n\n  handlePanResponderMove(e, gestureState) {\n    if (this.props.disabled) {\n      return;\n    }\n\n    this.setCurrentValue(this.getValue(gestureState));\n    this.fireChangeEvent('onValueChange');\n  }\n\n  handlePanResponderRequestEnd() {\n    // Should we allow another component to take over this pan?\n    return false;\n  }\n\n  handlePanResponderEnd(e, gestureState) {\n    if (this.props.disabled) {\n      return;\n    }\n\n    this.setCurrentValue(this.getValue(gestureState));\n    this.fireChangeEvent('onSlidingComplete');\n  }\n\n  thumbHitTest(e) {\n    var nativeEvent = e.nativeEvent;\n    var thumbTouchRect = this.getThumbTouchRect();\n    return thumbTouchRect.containsPoint(\n      nativeEvent.locationX,\n      nativeEvent.locationY\n    );\n  }\n\n  handleStartShouldSetPanResponder(e /*gestureState: Object*/) {\n    // Should we become active when the user presses down on the thumb?\n    return this.thumbHitTest(e);\n  }\n\n  fireChangeEvent(event) {\n    if (this.props[event]) {\n      this.props[event](this.getCurrentValue());\n    }\n  }\n\n  getTouchOverflowSize() {\n    var state = this.state;\n    var props = this.props;\n\n    var size = {};\n    if (state.allMeasured === true) {\n      size.width = Math.max(\n        0,\n        props.thumbTouchSize.width - state.thumbSize.width\n      );\n      size.height = Math.max(\n        0,\n        props.thumbTouchSize.height - state.containerSize.height\n      );\n    }\n\n    return size;\n  }\n\n  getTouchOverflowStyle() {\n    var { width, height } = this.getTouchOverflowSize();\n\n    var touchOverflowStyle = {};\n    if (width !== undefined && height !== undefined) {\n      var verticalMargin = -height / 2;\n      touchOverflowStyle.marginTop = verticalMargin;\n      touchOverflowStyle.marginBottom = verticalMargin;\n\n      var horizontalMargin = -width / 2;\n      touchOverflowStyle.marginLeft = horizontalMargin;\n      touchOverflowStyle.marginRight = horizontalMargin;\n    }\n\n    if (this.props.debugTouchArea === true) {\n      touchOverflowStyle.backgroundColor = 'orange';\n      touchOverflowStyle.opacity = 0.5;\n    }\n\n    return touchOverflowStyle;\n  }\n\n  handleMeasure(name, x) {\n    var { width, height } = x.nativeEvent.layout;\n    var size = { width: width, height: height };\n\n    var storeName = `_${name}`;\n    var currentSize = this[storeName];\n    if (\n      currentSize &&\n      width === currentSize.width &&\n      height === currentSize.height\n    ) {\n      return;\n    }\n    this[storeName] = size;\n\n    if (this._containerSize && this._trackSize && this._thumbSize) {\n      this.setState({\n        containerSize: this._containerSize,\n        trackSize: this._trackSize,\n        thumbSize: this._thumbSize,\n        allMeasured: true,\n      });\n    }\n  }\n\n  measureContainer(x) {\n    this.handleMeasure('containerSize', x);\n  }\n\n  measureTrack(x) {\n    this.handleMeasure('trackSize', x);\n  }\n\n  measureThumb(x) {\n    this.handleMeasure('thumbSize', x);\n  }\n\n  getValue(gestureState) {\n    var length = this.state.containerSize.width - this.state.thumbSize.width;\n    var thumbLeft =\n      this._previousLeft +\n      (this.props.orientation === 'vertical'\n        ? gestureState.dy\n        : gestureState.dx);\n\n    var ratio = thumbLeft / length;\n\n    if (this.props.step) {\n      return Math.max(\n        this.props.minimumValue,\n        Math.min(\n          this.props.maximumValue,\n          this.props.minimumValue +\n            Math.round(\n              ratio *\n                (this.props.maximumValue - this.props.minimumValue) /\n                this.props.step\n            ) *\n              this.props.step\n        )\n      );\n    } else {\n      return Math.max(\n        this.props.minimumValue,\n        Math.min(\n          this.props.maximumValue,\n          ratio * (this.props.maximumValue - this.props.minimumValue) +\n            this.props.minimumValue\n        )\n      );\n    }\n  }\n\n  getCurrentValue() {\n    return this.state.value.__getValue();\n  }\n\n  getRatio(value) {\n    return (\n      (value - this.props.minimumValue) /\n      (this.props.maximumValue - this.props.minimumValue)\n    );\n  }\n\n  getThumbLeft(value) {\n    var ratio = this.getRatio(value);\n    return (\n      ratio * (this.state.containerSize.width - this.state.thumbSize.width)\n    );\n  }\n\n  getThumbTouchRect() {\n    var state = this.state;\n    var props = this.props;\n    var touchOverflowSize = this.getTouchOverflowSize();\n\n    return new Rect(\n      touchOverflowSize.width / 2 +\n        this.getThumbLeft(this.getCurrentValue()) +\n        (state.thumbSize.width - props.thumbTouchSize.width) / 2,\n      touchOverflowSize.height / 2 +\n        (state.containerSize.height - props.thumbTouchSize.height) / 2,\n      props.thumbTouchSize.width,\n      props.thumbTouchSize.height\n    );\n  }\n\n  renderDebugThumbTouchRect(thumbLeft) {\n    var thumbTouchRect = this.getThumbTouchRect();\n    var positionStyle = {\n      left: thumbLeft,\n      top: thumbTouchRect.y,\n      width: thumbTouchRect.width,\n      height: thumbTouchRect.height,\n    };\n    return <Animated.View style={positionStyle} pointerEvents=\"none\" />;\n  }\n\n  render() {\n    const {\n      minimumValue,\n      maximumValue,\n      minimumTrackTintColor,\n      maximumTrackTintColor,\n      thumbTintColor,\n      containerStyle,\n      style,\n      trackStyle,\n      thumbStyle,\n      debugTouchArea,\n      thumbTouchSize,\n      onSlidingStart,\n      onSlidingComplete,\n      animationType,\n      animateTransitions,\n      animationConfig,\n      orientation,\n      ...other\n    } = this.props;\n\n    if (process.env.NODE_ENV !== 'test') {\n      delete other.onValueChange;\n    }\n\n    var {\n      value,\n      containerSize,\n      trackSize,\n      thumbSize,\n      allMeasured,\n    } = this.state;\n\n    var mainStyles = containerStyle || styles;\n    var thumbLeft = value.interpolate({\n      inputRange: [minimumValue, maximumValue],\n      outputRange: [0, containerSize.width - thumbSize.width],\n      //extrapolate: 'clamp',\n    });\n\n    var valueVisibleStyle = {};\n    if (!allMeasured) {\n      valueVisibleStyle.opacity = 0;\n    }\n\n    var minimumTrackStyle = {\n      position: 'absolute',\n      width: Animated.add(thumbLeft, thumbSize.width / 2),\n      backgroundColor: minimumTrackTintColor,\n      ...valueVisibleStyle,\n    };\n\n    const thumbStyleTransform = (thumbStyle && thumbStyle.transform) || [];\n    var touchOverflowStyle = this.getTouchOverflowStyle();\n    return (\n      <View\n        {...other}\n        style={[\n          mainStyles.container,\n          orientation === 'vertical' && { transform: [{ rotate: '90deg' }] },\n          style,\n        ]}\n        onLayout={this.measureContainer.bind(this)}\n      >\n        <View\n          style={[\n            { backgroundColor: maximumTrackTintColor },\n            mainStyles.track,\n            trackStyle,\n          ]}\n          onLayout={this.measureTrack.bind(this)}\n        />\n        <Animated.View\n          style={[mainStyles.track, trackStyle, minimumTrackStyle]}\n        />\n        <Animated.View\n          onLayout={this.measureThumb.bind(this)}\n          style={[\n            { backgroundColor: thumbTintColor },\n            mainStyles.thumb,\n            thumbStyle,\n            {\n              transform: [\n                { translateX: thumbLeft },\n                { translateY: -(trackSize.height + thumbSize.height) / 2 },\n                ...thumbStyleTransform,\n              ],\n              ...valueVisibleStyle,\n            },\n          ]}\n        />\n        <View\n          style={[styles.touchArea, touchOverflowStyle]}\n          {...this.panResponder.panHandlers}\n        >\n          {debugTouchArea === true && this.renderDebugThumbTouchRect(thumbLeft)}\n        </View>\n      </View>\n    );\n  }\n}\n\nSlider.propTypes = {\n  /**\n   * Initial value of the slider. The value should be between minimumValue\n   * and maximumValue, which default to 0 and 1 respectively.\n   * Default value is 0.\n   *\n   * *This is not a controlled component*, e.g. if you don't update\n   * the value, the component won't be reset to its inital value.\n   */\n  value: PropTypes.number,\n\n  /**\n   * If true the user won't be able to move the slider.\n   * Default value is false.\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * Initial minimum value of the slider. Default value is 0.\n   */\n  minimumValue: PropTypes.number,\n\n  /**\n   * Initial maximum value of the slider. Default value is 1.\n   */\n  maximumValue: PropTypes.number,\n\n  /**\n   * Step value of the slider. The value should be between 0 and\n   * (maximumValue - minimumValue). Default value is 0.\n   */\n  step: PropTypes.number,\n\n  /**\n   * The color used for the track to the left of the button. Overrides the\n   * default blue gradient image.\n   */\n  minimumTrackTintColor: PropTypes.string,\n\n  /**\n   * The color used for the track to the right of the button. Overrides the\n   * default blue gradient image.\n   */\n  maximumTrackTintColor: PropTypes.string,\n\n  /**\n   * The color used for the thumb.\n   */\n  thumbTintColor: PropTypes.string,\n\n  /**\n   * The size of the touch area that allows moving the thumb.\n   * The touch area has the same center has the visible thumb.\n   * This allows to have a visually small thumb while still allowing the user\n   * to move it easily.\n   * The default is {width: 40, height: 40}.\n   */\n  thumbTouchSize: PropTypes.shape({\n    width: PropTypes.number,\n    height: PropTypes.number,\n  }),\n\n  /**\n   * Callback continuously called while the user is dragging the slider.\n   */\n  onValueChange: PropTypes.func,\n\n  /**\n   * Callback called when the user starts changing the value (e.g. when\n   * the slider is pressed).\n   */\n  onSlidingStart: PropTypes.func,\n\n  /**\n   * Callback called when the user finishes changing the value (e.g. when\n   * the slider is released).\n   */\n  onSlidingComplete: PropTypes.func,\n\n  /**\n   * The style applied to the slider container.\n   */\n  style: ViewPropTypes.style,\n\n  /**\n   * The style applied to the track.\n   */\n  trackStyle: ViewPropTypes.style,\n\n  /**\n   * The style applied to the thumb.\n   */\n  thumbStyle: ViewPropTypes.style,\n\n  /**\n   * Set this to true to visually see the thumb touch rect in green.\n   */\n  debugTouchArea: PropTypes.bool,\n\n  /**\n  * Set to true to animate values with default 'timing' animation type\n  */\n  animateTransitions: PropTypes.bool,\n\n  /**\n  * Custom Animation type. 'spring' or 'timing'.\n  */\n  animationType: PropTypes.oneOf(['spring', 'timing']),\n\n  /**\n  * Choose the orientation. 'horizontal' or 'vertical'.\n  */\n  orientation: PropTypes.oneOf(['horizontal', 'vertical']),\n\n  /**\n  * Used to configure the animation parameters.  These are the same parameters in the Animated library.\n  */\n  animationConfig: PropTypes.object,\n  containerStyle: ViewPropTypes.style,\n};\n\nSlider.defaultProps = {\n  value: 0,\n  minimumValue: 0,\n  maximumValue: 1,\n  step: 0,\n  minimumTrackTintColor: '#3f3f3f',\n  maximumTrackTintColor: '#b3b3b3',\n  thumbTintColor: 'red',\n  thumbTouchSize: { width: 40, height: 40 },\n  debugTouchArea: false,\n  animationType: 'timing',\n  orientation: 'horizontal',\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    height: 40,\n    justifyContent: 'center',\n  },\n  track: {\n    height: TRACK_SIZE,\n    borderRadius: TRACK_SIZE / 2,\n  },\n  thumb: {\n    position: 'absolute',\n    width: THUMB_SIZE,\n    height: THUMB_SIZE,\n    borderRadius: THUMB_SIZE / 2,\n    top: 22,\n  },\n  touchArea: {\n    position: 'absolute',\n    backgroundColor: 'transparent',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n  },\n  debugThumbTouchArea: {\n    position: 'absolute',\n    backgroundColor: 'green',\n    opacity: 0.5,\n  },\n});\n"]}